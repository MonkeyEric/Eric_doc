# 1. 聊天头像-Gravatar
Gravatar提供的头像文件通过下面形式的URL获取：
```shell
https://gravatar.com/avatar/<HASH>
```
Gravatar使用电子邮件地址获取对应的用户头像，为了防止泄露用户的电子邮件地址，Gravatar采用通过MD5加密的邮件地址，上面的URL中的HASH部分就是电子邮箱的散列值。

为了降低服务器的负载，我们把用户Email地址的MD5散列值存储在数据库email_hash中。

## 1.1 第一个参数：d
地址：https://gravatar.com/avatar/<HASH>?d=monsterid
Gravatar支持的默认头像类别如下表:

| 类别  | 描述  |
| ------------ | ------------ |
| 404  |如果Email散列值没有对应的图片，那么返回HTTP404响应   |
|  mm | mm代表mystery-man(神秘人)，一个在灰色背景下的卡通风格人形边框  |
| identicon  | 基于Email散列值生成的集合形状  |
| monsterid  | 基于Email散列值生成的可爱小怪兽  |
| wavatar  | 基于Email散列值生成的卡通脸  |
| retro  | 基于Email散列值生成的8位像素风格的脸  |
| robohash  | 基于Email散列值生成的机器人  |
| blank   | 一个透明的带有边框的PNG图片  |


## 1.2 第二个参数：
参数s用来设置头像图片的大小，默认的头像图片的大小为80X80.下面的URL将某个头像尺寸设置为100X100:

https://gravatar.com/avatar/Sd3b9f7b7c0328827b57172e4a7abl36?size=lOO

# 2. 使用Flask-socketIO建立实时双向通信

# 2.1 websocket
> 常规轮询、长轮询、websocket的区别？
1. 轮询是传统方式，不存在浏览器兼容性问题，定时的发送网络请求
2. 轮询对客户端的电脑资源会造成额外的开销，如果页面中的定时器过多时不能实时获取最新的数据，获取数据会有延迟。
3. websocket对浏览器的版本有要求，低版本的浏览器不一定能用
3. websocket可以实时获取最新的数据，不会产生额外的开销。服务器有新的数据之后，会主动推送给客户端
4. 轮询是定时的发送的ajax请求，获取服务器的数据
5. 长轮询的方式：客户端向服务器发送请求之后，服务器会暂时把请求挂起，等到有数据更新时再返回最新的数据给客户端，客户端在接收到新的消息后再向服务器发送请求。与常规轮询的不同之处是：数据可以做到实时更新，可以减少不必要的开销



**送命题：选择还是长轮询还是常规轮询**
长轮询是不是总比常规轮询总有优势？我们可以从带宽占有的角度分析，如果一个程序数据更新太过频繁，假设每秒2次更新，如果使用长轮询的话每分钟要发送120次HTTP请求。如果使用常规轮询，每5秒发送一次请求的话，一分钟才20次，从这里常规轮询更有优势。
【长轮询，在请求到数据的时候，会再次请求服务器，服务器没有数据的时候，就挂着】

> websocket的优缺点

**优点**
* Websockets保持一个唯一的连接打开，同时消除长轮询的延迟问题
* Websockets通常不适用XMLHttpRequest，因此，当我们每次需要从服务器获取更多的信息时，无需发送头部数据。反过来，这又减少了数据发送到服务器时需要付出的高昂的数据负载代价
**缺点**
* 当连接终止时候，WebSockets无法自动恢复连接——这是需要你自己实现的部分，也是导致存在许多客户端库的原因
* 早于2011年的浏览器无法支持WebSocket链接
[拓展：SSE](https://www.cnblogs.com/goloving/p/9196066.html)
  
## 2.2 socketIO的介绍
* SocketIo是一个基于JavaScript实现实时通信的开源js库，它可以简化实时Web程序的开发过程
* 支持多种轮询机制以及其他模拟实时通信的方式
* 提供了诸如广播、命名空间、房间、存储客户端数据、异步IO等功能
* 要使用socketIO,客户端和服务端都需要使用Socket.IO框架。
> flask服务端使用flask_socketio，客户端使用socket.io.min.js