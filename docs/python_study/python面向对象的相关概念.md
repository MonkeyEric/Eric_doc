# python面向对象
python中一切数据都是对象，一切变量都是引用。
## 1. 面向对象技术简介

* 类（class）：用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
* 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。
* 实例变量：定义在方法中的变量，只作用于当前实例的类。
* 继承：即一个派生类继承基类的字段和方法。继承也允许把一个派生类的对象最为衣蛾基类对象对待。
*方法：类中定义的函数
* 对象：通过类定义的数据包结构实例。包括两个数据成员（类变量和实例变量）和方法。

**面向对象的特征：封装、继承、多态、抽象。**

所有语言的面向对象的基类是 **object**

在程序设计时，尽量避免使用相同的方法名、相同的变量（子变量来替代父变量中的方法）

**Java和.net只支持单继承。python、C++即支持单又支持多继承。**

既然student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在student类的内部定义访问数据的函数，这样，就把数据给封装起来了。

## 2. 重载VS重写
1. 重载： 			

	相同的方法名具有不同的参数个数或者参数类型，那么它就叫重载，这是强类型语言中的写法。

	重载：相同的方法名具有不同的参数个数或者类型，在python中方法名不能相同！！
2. 重写：

	子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，保留父类的东西，子类重新添加一些东西。如果想要保留父类的方法，就创建一个函数，直接调用类的方法。

## 3. python内置类属性
* __dict__类的属性（包含一个字典，由类的数据属性组成）
* __doc__类的文档字符串
* __name__类名
* __module__类顶一记所在的模块
* __bases__类的所有父类构成元素（包含了一个由所有父类组成的元组）
* __del__   当进程结束了，会运行del下边的程序

```
例如：def __del__(self):
        print(‘哦，进程它已经死了~~’)
		
例如：
__str__描述对象信息，必须return
def __str__(self):
        return '这个人的名字叫%s,年龄%s,性别%s' % (self.name, self.age, self.sex)
__init__由python解释器自动调用，存在意义：给对象属性赋值，不是必须写的。
__name__='__main__'具体理解见笔记本
```
## 4. self对象的引用。
私有的方法和属性不可以被对象访问，也不可以被继承，安全系统更高一些。

## 5. 类的创建过程
1. 创建一块内存，将类中的方法或属性赋值，不能复制私有的方法或属性。
2. python解释器自动调用__init__方法
3. 返回对象的引用
```python 
class Dog():
	name='xiaohuang' #类的属性
	__age=9 #；类的私有属性，不能在类的外部被使用或直接访问。在类内部的方法中使用时self.__private_attrs
	@classmethod
	def sleep(cls): #类的方法调用，有cls参数
		print('classmethod name is :%s'%cls.name)
	@staticmethod
	def ddd(): #静态方法，不需要参数
		print('staticmethod name is static!')
	def __init__(self,color): #将对象的属性赋值
		self.color=color
		self.__sex=None #对象的私有属性，只能是允许这个类本身进行访问了。
	def setSex(self,sex):
		if sex !='公' and sex !='母':
			self.__sex='公'
		else:
			self.__sex=sex
	def getSex(self):
		return self.__sex
	def yaoren(self):
		print('狗咬人')
	def eat(self):
		print('狗吃饭')
	def __drink(self): #对象的私有方法，只能对象才能访问。
		print('狗喝水') #只有self才可以访问,同理__Sex也是

dog1 = Dog('黑色')
print(dog1.color)
dog1.setSex('红')
print(dog1.getSex())
print(dog1.name) #对象也可以访问类的属性，但是类不可以访问对象的属性。
dog1.ddd() #对象可以访问静态方法。

"""以上都是对象的！"""
print('以上都是对象的')
print(Dog.name) #类访问自己的属性
Dog.sleep() #类访问自己的方法
Dog.ddd() #类也可以访问静态方法。
dog1.eat()
dog2=Dog('绿色')
print(dog2.color)

# 最后的结果为：
黑色
公
xiaohuang
staticmethod name is static!
以上都是对象的
xiaohuang
classmethod name is :xiaohuang
staticmethod name is static!
狗吃饭
绿色
```
    
*静态：程序一运行就创建，不管用户是否需要；程序一运行，就会将静态的东西塞入内存，只有当python进程结束的时候，才会被操作系统一起回收。
* 动态：程序在使用的过程中，创建。
    
看到classmethod和staticmethod 知道这些方法时类方法或者静态方法
### 5.1 静态方法的作用？   
就是不使用参数
```
@staticmethod
def static_method():
  print 'This is static method.'
 类方法有cls参数，静态方法不需要参数。self是对象的参数
```

## 6. 属性和方法：

### 6.1 属性
1. cls类属性：公有的类属性，对象和类都可以范文，静态方法不可以访问，私有的，都不可以访问。
2. self对象属性：公有的属性只能由对象访问
__开始的表示是私有的，私有的属性不可以被对象或者类访问。

###6.2 方法：
1. self对象方法：公有的对象方法只能由对象访问   对象.方法名
2. cls类方法：公有的类方法可以有对象和类共同访问   类名.方法名  对象.方法名
3. 静态方法：公有的静态方法也可以被对象和类共同访问   类名.方法名  对象.方法名



## 7. python对象销毁（垃圾回收）

python使用了引用计数这一简单计数来跟踪和回收垃圾。在python内部记录着所有使用中的对象各有多少引用。

一个内部跟踪变量，称为一个引用计数器。

当对象被创建时，就创建了一个引用计数，当这个对象不再需要时，也就是说，这个对象的引用计数变为0时，它被垃圾回收。但是回收不是“立即的”，由解释器在适当的实际，将垃圾对象占用的内存空间回收。
```python
a = 40 # 创建对象 <40>
b = a # 增加引用， <40> 的计数
c = [b] # 增加引用. <40> 的计数

del a # 减少引用 <40> 的计数
b = 100 # 减少引用 <40> 的计数
c[0] = -1 # 减少引用 <40> 的计数
```

垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量来引用他们。这种情况下，仅适用引用计数是不够的。

python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充，垃圾收集器也会留心被分配的总量很大的（及未通过引用计数销毁的那些）对象。在这种情况下，解释器会暂停下来，试图清理所有未引用的循环。

## 8. 类的继承

面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。

需要注意的地方：继承语法class 派生类名（基类名）：
### 8.1 继承的特点：
1. 在继承中基类的构造（__init__（）方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。
2. 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量
3. python总是首先查找对应类型的方法，如果他不能再派生类中找到对应的方法，它才开始到基类中寻找。
