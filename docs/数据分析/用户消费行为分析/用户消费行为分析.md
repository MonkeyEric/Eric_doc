## 第一部分 数据加载
* 数据加载
    * 字段含义：
        * user_id：用户id
        * order_dt: 购买日期
        * order_product:购买产品的数量
        * order_amount: 购买金额
* 观察数据
    * 查看数据的数据类型
    * 数据中是否存储在缺失值
    * 将order_dt转换成时间类型
    * 查看数据的统计描述
        * 计算所有用户购买商品的平均数量
        * 计算所有用户购买商品的平均花费
    * 在源数据中添加一列表示月份:astypte('datetime64['M']')
```python
import pandas as pd
from matplotlib.pyplot import plot
df =  pd.read_csv('./CDNOW_master.txt',delimiter='\s+',header=None,names=['user_id','order_dt','order_product','order_amount'])
df['order_dt'] = pd.to_datetime(df['order_dt'],format='%Y%m%d')
# 查看数据的统计描述
df.describe()
# 在源数据中添加一列表示月份:astypte('datetime64['M']')
df['month']= df['order_dt'].astype('datetime64[M]')
df
```


## 第二部分： 按月数据分析
* 用户每月花费的总金额
    * 绘制曲线图表示
* 所有用户每月的产品购买量
* 所有用户每月的消费总次数
* 统计每月的消费人数
```python
# 用户每月花费的总金额
df.groupby(by='month')['order_amount'].sum().plot()
#  所有用户每月的产品购买量
df.groupby(by='month')['order_product'].sum()
# * 所有用户每月的消费总次数
df.groupby(by='month')['user_id'].count().plot()
# * 统计每月的消费人数
# nunique统计去重后的个数
df.groupby(by='month')['user_id'].nunique()


```

## 第三部分：用户个体消费数据分析
* 所有用户消费总金额和消费总购买量的统计描述
* 各个用户消费金额和消费产品数量的散点图
* 各个用户消费总金额的直方分布图（消费金额在1000之内的分布）
* 各个用户消费的总数量的直方分布图（消费商品的数量在100次之内的分布）
```python
# 用户每月花费的总金额
df.groupby(by='month')['order_amount'].sum().plot()
#  所有用户每月的产品购买量
df.groupby(by='month')['order_product'].sum()
# * 所有用户每月的消费总次数
df.groupby(by='month')['user_id'].count().plot()
# * 统计每月的消费人数
# nunique统计去重后的个数
df.groupby(by='month')['user_id'].nunique()
# 所有用户消费总金额和消费总购买量的统计描述 describe没有sum

df['order_amount'].sum()
df['order_product'].sum()
# * 各个用户消费金额和消费产品数量的散点图
x = df.groupby('user_id')['order_amount'].sum()
y = df.groupby('user_id')['order_product'].sum()
plt.scatter(x,y)
# 各个用户消费总金额的直方分布图（消费金额在1000之内的分布）
order_amount = df.groupby(by='user_id').sum().query('order_amount <= 1000')['order_amount']
plt.hist(order_amount,bins=30)
# * 各个用户消费的总数量的直方分布图（消费商品的数量在100次之内的分布）
order_product = df.groupby(by='user_id').sum().query('order_product <= 100')['order_product']
plt.hist(order_product)
```


## 第四部分：用户消费行为分析
- 用户第一次消费的月份分布，和人数统计
    - 绘制线形图
* 用户最后一次消费的时间分布，和人数统计
    * 绘制线型图
* 新老客户的占比
    * 消费1次为新用户
    * 消费多次为老用户
        - 分析出每一个用户的第一个消费和最后一次消费时间
        - 分析出新老客户的消费比例
* 用户分层
    * 分析得出每个用户的总购买量和总消费金额and最近一次消费的四化建的表格rfm
    * RFM模型设计
        * R表示客户最近一次交易时间的间隔
            * np.timedelta64(1,'D''):去除days
        F表示客户购买商品的总数量，F值越大，表示客户交易越频繁，反之则表示客户交易不够活跃
        M表示客户交易的金额。M值越大，表示客户价值越高，反之则表示客户价值越低
        将R,F,M作用到RFM表中
    * 根据价值分层，将用户分为：
        * 重要价值客户
        * 重要保持客户
        * 重要挽留客户
        * 重要发展客户
        * 一般价值客户
        * 一般保持客户
        * 一般挽留客户
        * 一般发展客户
            * 使用已有的分层模型即可rfm_func
    
```python
# 用户第一次消费的月份分布，和人数统计
# 如何判定用户的第一次消费的月份？ 用户消费的最小值就是用户首次消费的月份
df.groupby(by='user_id')['month'].min().unique()
df.groupby(by='user_id')['month'].min().value_counts()
# * 用户最后一次消费的时间分布，和人数统计
df.groupby(by='user_id')['month'].max().unique()
df.groupby(by='user_id')['month'].max().value_counts()
# * 新老客户的占比
# 消费一次为新用户，消费多次为老用户，如何判定？求出用户的第一次的消费时间和最后一次消费时间，如果这两个时间一样，则表示用户只消费了iyci，否则表示消费多次
# agg用于将分组后的结果进行多种不同形式的聚合操作
first_last = df.groupby(by='user_id')['order_dt'].agg(['min','max'])
(first_last['max']== first_last['min']).value_counts() # true消费了一次，false消费了多次
# * 分析得出每个用户的总购买量和总消费金额and最近一次消费的四化建的表格rfm
# 最近一次的消费时间。用户消费时间的最大值
rfm = df.groupby(by='user_id').sum()
rfm.head()
# 用户最近一次消费时间
user_recently_order_dt = df.groupby(by='user_id')['order_dt'].max()
rfm['R'] = user_recently_order_dt
# RFM模型设计
rfm.columns= ['F','M','R']
rfm.head()
# R 表示最近一次的交易的时间间隔
# 时间间隔=所有时间的最大值-客户最后一次交易的时间
# np.timedelta64(1,'D')是为了去除Days的样式
import numpy as np
rfm['R'] = df['order_dt'].max() - rfm['R']
rfm['R'] = rfm['R'] / np.timedelta64(1,'D')
# rfm分层算法
def rfm_func(x):
    # 存储的是三那个字符串形式的0或者1
    level = x.map(lambda x:'1' if x >0 else '0')
    label = level['R']+ level.F+ level.M
    d = {
        '111':'重要价值客户',
        '011':'重要保持客户',
        '101':'重要挽留客户',
        '001':'重要发展客户',
        '110':'一般价值客户',
        '010':'一般保持客户',
        '100':'一般挽留客户',
        '000':'一般发展客户'
    }
    result = d [label]
    return result
# df.apply(func) 可以对df中的行或者列进行某种func的运算
rfm['label'] = rfm.apply(lambda x: x-x.mean(),axis=0).apply(rfm_func,axis=1)
```
              
## 第五部分：用户的生命周期
* 将用户划分未活跃用户和其他用户
    * 统计每个用户每个月的消费次数
    * 统计每个用户每个月是否兄消费，消费记录为1否则记录为0
        * 知识点：DataFrame的apply和applymap的区别
            * applymap：返回df
            * 将函数作用于Dataframe中的所有元素(elements)
            * apply:返回Series
            * apply()将一个函数作用于DataFrame的每个行或者列
    * 将用户按照每一个月份分成：
        * unreg:观望用户（前两月没买，第三个月才第一次买，则用户前连个月为观望用户）
        * unactive:首月购买后，后序月份没有购买，则在没有购买的月份中该用户的为非活跃用户
        * new:当前月就进行首次购买的用户在当前月为新用户
        * active:连续月份购买的用户在这些月中为活跃用户
        * return :购买之后间隔n月再次购买的第一个月份为该月份的回头客 
    * 每月【不同活跃】用户的计数
    

```python
# 第五部分
# 统计每个用户每个月的消费次数。
# 1.根据usr_id统计order_dt的次数，在所有时间的消费次数
# df.pivot_table(index='user_id',values='order_dt',aggfunc='count')
# 2. 
usr_month_order_count = df.pivot_table(index='user_id',values='order_dt',aggfunc='count',columns='month',fill_value=0)
# * 统计每个用户每个月是否兄消费，消费记录为1否则记录为0
df_purchase = usr_month_order_count.applymap(lambda x: 1 if x>0 else 0)
df_purchase.head()
# 将df_purchase中的原始数据0和1修改为new，unactive……，返回新的df叫做df_purchase_new
# 固定算法
def active_status(data):
    status = [] # 某个用户一个月的活跃度
    for i in range(18):
        # 若本月没有消费
        if data[i]>0:
            if len(status) >0:
                if status[i-1] == 'unreg':
                    status.append('unreg')
                else:
                    status.append('unactive')
            else:
                status.append('unreg')
        # 若本月消费                
        else:
            if len(status) == 0:
                status.append('new')
            else:
                if status[i-1] == 'unactive':
                    status.append('return')
                elif status[i-1] == 'unreg':
                    status.append('new')
                else:
                    status.append('active')
    return status

pivoted_status = usr_month_order_count.apply(active_status,axis=1)
pivoted_status.head()
# 将上述的内容封装到df中
from pandas import DataFrame
df_purchase_new = DataFrame(data=pivoted_status.values.tolist(),index=df_purchase.index,columns=df_purchase.columns)
df_purchase_new.head()

# * 每月【不同活跃】用户的计数
df_ new = df_purchase_new.apply(lambda x:pd.value_counts(x),axis=0).fillna(0).T
```
    